Задача 1

* Да се дефинирира метод int Tree::height(...)

* Де се дефинира метод int Tree::count(...), който преброява всички елементи на дървото

* Да се дефинира метод int Tree::countLeaves(...), който намира броя на листата на дървото

* Да се дефинира метод T Tree::sum (const T& null_val) на клас Tree, който намира и връща сумата на всички елементи на дървото
  (резултатът от приложението на оператора + над елементите. Нулевата стойност на типа се задава от параметъра null_val)

* Да се дефинира метод Tree::leaves(), който намира и връща вектор, съдържащ стойностите на всики листа на дървото

* Да се дефинира метод Tree::level (int k), който намира и връща вектор, съдържащ стойностите на всики елементи на дървово,
  които са на ниво k (т.е. има път от корена до тях с дължина k)

* Да се построи някое покриващо дърво на лабиринт


Задача 2

 *Да се дефинира метод Tree::insertSorted (const T& x). Методът приема, че дървото е ДНД (двоично наредено дърво) и вмъква
 елемента x в него така, че то да остане ДНД

* Да се дефинира метод Tree::isBOT (), който проверява дали дървото е ДНД. Методът да се реализира чрез рекурсия и чрез стек

* Да се дефинира метод bool Tree::memberBOT (const T& x), който проверява дали x е елемент на ДНД

* Да се дефинира метод bool Tree::memberGeneral (const T& x), който проверява дали x е елемент дървото (което може да не е ДНД)


Задача 3

* Да се дефинира функция [...] lоngestProgression (g), която намира най-дългия път в граф g, състоящ се от нарастващи по
  стойност върхове (върховете имат тежест). Може да се използва всяко представяне на граф.

* Да се дефинира функция vector<int> shоrtestWay(string file), която по дадено име на файл, който съдържа
  представяне граф, намира най-късия път между два върха прочетени от клавитурата. Във файла на всеки ред има числа с
  разстояние помежду им. Всяко число и номер на връх в графа. Първото число на всеки ред е върха който има ребра сочещи към
  останалите върхове.
